# 第1章-线程基础知识复习

## 1.1 简介

​	Doug Lea(道格*利)编写的，java.util.concurrent工具包。

## 1.2 为什么学习多线程

### 1.2.1 硬件方面：摩尔定律失效

​	摩尔定律：它是由英特尔创始人之一Gordon Moore 提出来的。其内容为：

​	当价格不变时，集成电路上可容纳的元器件的数目约每个18-24个月便会增加一倍，性能也将提升一倍。

​	换言之，每一美元所能买到的电脑性能，将每个18-24个月翻一倍以上。这一定律揭示了信息技术进步的速度。

​	可时从2003年开始CPU主频已经不再翻倍，而是采用多核而不是更快的主频。

​	在主频不再提交且核数不断增加的情况下，要想让程序更快就要用到并行或并发编程。

### 1.2.2 软件方面

* 充分利用多核处理器

* 提高程序性能，并发系统

* 提高程序吞吐量，异步+回调等生产需求

### 1.2.3 弊端及问题

* 线程安全性问题
  * i++是否安全
  * 集合类是否安全
* 线程锁问题
* 线程性能问题

### 1.3 线程开始start

​	线程启动通过start方法进行启动。

* java线程理解以及openjdk中的实现
  * private native void start0()
  * Java语言本身底层就是C++语言
  * OpenJDK源码网站
    * http://openjdk.java.net

* 更加底层的C++源码解读

1把锁：synchronized（后面细讲）
●2个并：
○并发（concurrent）：是在同一实体上的多个事件，是在一台机器上“同时”处理多个任务，同一时刻，其实是只有一个事情再发生。
○并行（parallel）：是在不同实体上的多个事件，是在多台处理器上同时处理多个任务，同一时刻，大家都在做事情，你做你的，我做我的，各干各的。
●3个程：
○进程：在系统中运行的一个应用程序，每个进程都有它自己的内存空间和系统资源
○线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。
○管程：Monitor（锁），也就是我们平时所说的锁。Monitor其实是一种同步机制，它的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码，JVM中同步是基于进入和退出监视器（Monitor管程对象）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象和Java对象一同创建并销毁，底层由C++语言实现。
●线程分类（一般不做特别说明配置，默认都是用户线程）：
○用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。
○守护线程：是一种特殊的线程为其他线程服务的，在后台默默地完成一些系统性的任务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，守护线程伴随着JVM一同结束工作。

```java
public class DaemonDemo {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 开始运行," + (Thread.currentThread().isDaemon() ? "守护线程" : "用户线程"));
            while (true) {

            }
        }, "t1");
        t1.setDaemon(true);//通过设置属性Daemon来设置当前线程是否为守护线程
        t1.start();
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread().getName() + " 主线程结束");
    }
}


输出：t1 开始运行,守护线程
main 主线程结束--->在main主线程结束后，守护线程会伴随着JVM一同结束工作，即使还有循环没有结束

```

