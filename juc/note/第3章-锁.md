# 第3章-锁



## 3.1 大场面试题复盘

* 你怎么理解Java多线程的？怎么处理并发？线程池有哪几个核心参数？

* Java加锁有哪几种锁？
* 简单说说lock？
* HashMap的实现原理？hash冲突怎么解决？为什么使用红黑树？
* 项目中那个地方用了countdownlanch，怎么使用的？

## 3.2 乐观锁和悲观锁

* 悲观锁

  * 认为自己在使用数据时有一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
  * synchronized关键字和Lock的实现类都是悲观锁。
  * 适合写操作多的场景，先加索可以保证写操作时数据正确。
  * 显式的锁定之后再操作同步资源

* 乐观锁

  * 认为自己在是应用数据时不会有别的线程修改数据或资源，所以不会添加锁。
  * 在Java中时通过使用无锁编程来实现，只有在更新数据的时候去判断，之前有没有别的线程更新了这个数据。
  * 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。
  * 如果这个数据已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如放弃修改、重试抢锁等等。
  * 判断规则：版本号机制Version或最常采用的是CAS（Compare-and-Swap，即比较并替代）算法，Java原子类中的递归操作就是通过CAS自旋实现的。
  * 适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

* 伪代码说明

  ```java
  //悲观锁的调用方式
  public synchronized void m1(){
  //加锁后的业务逻辑
  }
  //保证多个线程使用的是同一个Lock对象的前提下
  ReentrantLock lock = new ReentrantLock();
  public void m2(){
  	lock.lock();
  	tyr{
  		//操作同步资源
  	}finally{
  		lock.unlock();
  	}
  }
  
  //乐观锁的调用方式
  //保证多个线程使用的是同一个AtomicInteger
  private AtomicInteger atomicInteger = new AtomicInteger();
  atomicInteger.incrementAndGet();
  ```

## 3.3 8中情况演示锁运行

* 锁相关的8中案例演示code

  ```
  /**
   * 题目：谈谈你对多线程锁的理解,8锁案例说明
   * 口诀：线程   操作  资源类
   * 8锁案例说明：
   * 1 一个对象都是有多个非静态synchronized方法，多个线程去访问不同的方法。
   * 2 在1的基础上，第一个线程睡眠3秒钟
   * 3 在2的基础上添加一个普通方法
   * 4 在1的基础上，创造两个对象
   * 5 有两个静态同步方法
   * 6 有两个静态同步方法，两个对象
   * 7 有1个静态同步方法，1个非静态同步方法
   * 8 有1个静态同步方法，1个非静态同步方法，两个对象
   *
   * 笔记总结：
   * 1-2
   *  *  *  一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，
   *  *  *  其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些synchronized方法
   *  *  *  锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法
   *  3-4
   *  *  加个普通方法后发现和同步锁无关
   *  *  换成两个对象后，不是同一把锁了，情况立刻变化。
   *
   *  5-6 都换成静态同步方法后，情况又变化
   *  三种 synchronized 锁的内容有一些差别:
   * 对于普通同步方法，锁的是当前实例对象，通常指this,具体的一部部手机,所有的普通同步方法用的都是同一把锁——>实例对象本身，
   * 对于静态同步方法，锁的是当前类的Class对象，如Phone.class唯一的一个模板
   * 对于同步方法块，锁的是 synchronized 括号内的对象
   *
   * *  7-8
   *  *    当一个线程试图访问同步代码时它首先必须得到锁，正常退出或抛出异常时必须释放锁。
   *  *  *
   *  *  *  所有的普通同步方法用的都是同一把锁——实例对象本身，就是new出来的具体实例对象本身,本类this
   *  *  *  也就是说如果一个实例对象的普通同步方法获取锁后，该实例对象的其他普通同步方法必须等待获取锁的方法释放锁后才能获取锁。
   *  *  *
   *  *  *  所有的静态同步方法用的也是同一把锁——类对象本身，就是我们说过的唯一模板Class
   *  *  *  具体实例对象this和唯一模板Class，这两把锁是两个不同的对象，所以静态同步方法与普通同步方法之间是不会有竞态条件的
   *  *  *  但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。
   */
  ```

  * 小结

    * 阿里开发手册，【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无所数据结构，就不要用锁；能锁区块，就不要锁整个方法体，能用对象锁，就不要用类锁。尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。

    ![image-20240625081326565](D:\IdeaProjects\learn\juc\image\image-20240625081326565.png)

* synchronized有三种应用方式

  * JDK源码（notify方法）说明举例

  ![](D:\IdeaProjects\learn\juc\image\image-20240625083038335.png)

  * 8中锁的案例实际体现在3个地方
    * 作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁。
    * 作用于代码块，对括号里配置的对象加锁。
    * 作用域静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁。

* 从字节码角度分析synchronized实现

  * javap -c ***.class文件反编译，javap -v或verbose 输出附加信息（包括行号，本地变量表，反汇编等详细信息）
  * synchronized同步代码块
    * 使用的monitorenter和monitorexit指令实现
    * 一般情况1个enter对应两个exit，是因为异常时也能释放锁
    * 极端情况只有1个enter和1个exit（只有抛出异常时释放锁的代码）

  ![image-20240625082752532](D:\IdeaProjects\learn\juc\image\image-20240625082752532.png)

  ![image-20240625083239383](D:\IdeaProjects\learn\juc\image\image-20240625083239383.png)

  * synchronized普通同步方法
    * 调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设设置。如果设置了，执行线程会将先持有monitor锁，然后再在执行方法，最后再方法完成时（无论正常还是异常完成）释放monitor。
  * synchronized静态同步方法
    * ACC_STATIC,ACC_SYNCHRONIZED访问标志区分该方法是否静态同步方法。

  ![image-20240702065901569](D:\ideaprojects\learn\juc\image\image-20240702065901569.png)

* 反编译synchronized锁的是什么

  * HotSpot虚拟机追踪，monitor采用ObjectMonitor实现
  * 每个对象天生都带一个对象监视器
  * 每一个被锁住的对象都会和Monitor关联起来

  ![image-20240702070112825](D:\ideaprojects\learn\juc\image\image-20240702070112825.png)

  ![image-20240702070143513](D:\ideaprojects\learn\juc\image\image-20240702070143513.png)

* 对于synchronized关键字，synchronized与锁升级章节还会深度讲解

  ![image-20240702070901439](D:\ideaprojects\learn\juc\image\image-20240702070901439.png)

  ![image-20240702070925247](D:\ideaprojects\learn\juc\image\image-20240702070925247.png)

## 3.4 公平锁和非公平锁

* 何为公平锁/非公平锁
  * 公平锁
    * 指多个线程按照申请锁的顺序来获取锁，Lock lock = new ReetrantLock(true)，表示公平锁，先来先得
  * 非公平锁
    * 指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转或则饥饿的状态（某一个线程一直得不到锁）
    * Lock lock = new ReetrantLock(false)；表示非公平锁，后俩的也可能先获得锁
    * Lock lock = new ReetrantLock()；//默认非公平锁
* 预埋伏AQS

## 3.5 可重入锁（递归锁）

## 3.6 死锁排查

## 3.7 写锁（独占锁）/读锁（共享锁）

## 3.8 自旋锁SpinLock

## 3.9 无锁-->独占锁-->读写锁-->邮戳锁

## 3.10 无锁-->偏向锁-->轻量锁-->重量锁

