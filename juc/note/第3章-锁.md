# 第3章-锁



## 3.1 大场面试题复盘

* 你怎么理解Java多线程的？怎么处理并发？线程池有哪几个核心参数？

* Java加锁有哪几种锁？
* 简单说说lock？
* HashMap的实现原理？hash冲突怎么解决？为什么使用红黑树？
* 项目中那个地方用了countdownlanch，怎么使用的？

## 3.2 乐观锁和悲观锁

* 悲观锁

  * 认为自己在使用数据时有一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
  * synchronized关键字和Lock的实现类都是悲观锁。
  * 适合写操作多的场景，先加索可以保证写操作时数据正确。
  * 显式的锁定之后再操作同步资源

* 乐观锁

  * 认为自己在是应用数据时不会有别的线程修改数据或资源，所以不会添加锁。
  * 在Java中时通过使用无锁编程来实现，只有在更新数据的时候去判断，之前有没有别的线程更新了这个数据。
  * 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。
  * 如果这个数据已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如放弃修改、重试抢锁等等。
  * 判断规则：版本号机制Version或最常采用的是CAS（Compare-and-Swap，即比较并替代）算法，Java原子类中的递归操作就是通过CAS自旋实现的。
  * 适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。

* 伪代码说明

  ```java
  //悲观锁的调用方式
  public synchronized void m1(){
  //加锁后的业务逻辑
  }
  //保证多个线程使用的是同一个Lock对象的前提下
  ReentrantLock lock = new ReentrantLock();
  public void m2(){
  	lock.lock();
  	tyr{
  		//操作同步资源
  	}finally{
  		lock.unlock();
  	}
  }
  
  //乐观锁的调用方式
  //保证多个线程使用的是同一个AtomicInteger
  private AtomicInteger atomicInteger = new AtomicInteger();
  atomicInteger.incrementAndGet();
  ```

## 3.3 8中情况演示锁运行

* 锁相关的8中案例演示code
* synchronized有三种应用方式
* 从字节码角度分析synchronized实现
* 反编译synchronized锁的是什么
* 对于synchronized关键字，synchronized与锁升级章节还会深度讲解

## 3.4 公平锁和非公平锁

## 3.5 可重入锁（递归锁）

## 3.6 死锁排查

## 3.7 写锁（独占锁）/读锁（共享锁）

## 3.8 自旋锁SpinLock

## 3.9 无锁-->独占锁-->读写锁-->邮戳锁

## 3.10 无锁-->偏向锁-->轻量锁-->重量锁

