# 第1章：基础知识和原理
## 1.简介

一套用于构建用户界面（后端数据如何展示给前端）的渐进式（逐层开发，需要再引入）javaScript框架

### 1.1.1历史

尤雨溪 13年受到Angular.js启发开发，14年对外发布，15年10月27日发布1.0，16年10月1日发布2.0，20年9月18日发布3.0

### 1.1.2 Vue特点

- 采用组件化模式，提高代码复用率、且让代码更好维护。
- 声明式编码（不是命令式编码<写一行代码，代码执行以下>，有点像后端jsp或则springEL表达式），让编码人员无需直接操作DOM，提高开发效率。
- 操作虚拟dom，采用优秀的Diff算法，尽量服用DOM节点。

### 1.1.3 学习VUE需要掌握的JavaScript基础知识

- ES6语法规范
- ES6模块化
- 包管理器
- 原型、原型链
- 数组常用方法
- axios
- promise

### 1.1.4 Vue官网使用

- 学习-->教程

- 学习-->API

- 学习-->风格指南（编码规范推荐）

- 学习-->示例

- 学习-->cookbook(技巧，怎么做更好)

- 资源列表--> awesome-vue(一些好的第三方框架)

## 1.2 VUE入门

### 1.2.1 安装

初学者：

- 官网下载
- https://cn.vuejs.org/v2/guide/installation.html
- 通过script引入vue可以用，还可以通过npm安装，脚手架使用。开始学习，首先通过scprit引入进行学习。
- vue.js开发版本，vue.min.js生产版本
- 安装Vue开发者工具，chrome
  https://devtools.vuejs.org/guide/installation.html    Get the Chrome Extension
### 1.2.2 Hello Wrold

Vue.config 是全局配置，可以在scipt进行配置修改。

```vue
Vue.config.productionTip = false;//关闭生产提示
```

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初始Vue</title>
    <script src="../js/vue.js"></script>
</head>
<body>
<div id="app">
    {{ message.toUpperCase() }}
    {{ data }}
</div>
</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var app = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            message: 'Hello Vue!',
            data: 'Hello Data!'
        }
    })
</script>
</html>
```

### 1.2.3 Vue一些注意事项

- 要使用Vue工作，需要创建一个Vue实例，传入一个配置对象。

- root容器里的代码依然符合html规范，只要不混入vue的语法。

- root容器里的代码被称为Vue模板。

- el表示挂在目标，Element的意思。

- data表示数据，给挂在目标中的语法参数赋值。

- 真实开发中只有一个Vue实例，且会配合组件一起使用

- Vue语法，插入值  用两个大括号表示。{{}}，大括号里面的内容是js表示式（不是js代码），且可以自动读取到Data中的所有属性。

  表达式如：（1）a 是表达式（2）a+b （3）demo(1) (4)x==y?'a':=='b'。表达式可以给变量赋值。、

- 一个Vue实例，对应一个容器，即一一对应。如果有多个容器，只有有第一个生效。

  例如：如下代码只有第一个app生效。

```vue
<div class="app">
    {{ message }}
    {{ data }}
</div>
<div class="app">
    {{ message }}
    {{ data }}
</div>
    var app = new Vue({
        el: '.app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            message: 'Hello Vue!',
            data: 'Hello Data!'
        }
    })
```

如下代码：只会打印Hello Vue,也就是说的一个Vue实例接管了一个容器，后面的Vue实例不生效。
```vue
    <div id="root">
        {{ message }}
        {{ data }}
    </div>
    
    var app = new Vue({
            el: '#root',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
            data: {//data中供容器使用，值先写成一个对象
                message: 'Hello Vue!'
            }
        })
    var app = new Vue({
        el: '#root',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            data: 'Hello Data!'
        }
    })
```
## 1.3 模板语法

### 1.3.1 插值语法

只能用于标签内的内容，标签中的文本。

### 1.3.2 指令语法

用于标签属性。绑定html属性，不能使用两个大括号，需要使用v-bind:，简写为：,Vue就会将后面的属性当作js表达式处理，赋值Vue实例Data中的数据。Vue中的指令都是v-开头的。

```vue
<div id="app">
    {{ message.toUpperCase() }}
    {{ data }}
    <hr>
    <a href="url">点我跳转1</a>
    <a v-bind:href="url">点我跳转2</a>
    <a :href="url">点我跳转2</a>
</div>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var app = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            message: 'Hello Vue!',
            data: 'Hello Data!',
            url: 'http://www.baidu.com'
        }
    })
</script>
```

### 1.3.3 数据绑定

v-bind指令只能单向绑定到页面中，页面中的数据不能影响Vue实例data的数据。使用v-model:是双向绑定的，且只能应用于表单类元素（即有value属性的元素），v-model:value可以简写v-model。

```vue
<div id="app">
    <h1>数据绑定</h1>
    输入框1:<input type="text" v-bind:value="inputBindValue" />
    <br/>
    输入框2:<input type="text"  :value="inputBindValue" />
    <br/>
    输入框3:<input type="text"  v-model:value="inputModelValue" />
    <br/>
    输入框4:<input type="text"  v-model="inputModelValue" />
    <br/>
</div>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var app = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            inputBindValue: '单向绑定元素变量，改变后下面边框不会修改',
            inputModelValue: '双向变量，改变后下面边框不会修改'
        }
    })
</script>
```

### 1.3.4 el和data两种写法

-  el可以再new Vue时写入，可以在实例.$mount属性设置

```vue
Vue.config.productionTip = false;//关闭生产提示
var app = new Vue({
    // el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
    data: {//data中供容器使用，值先写成一个对象
        message: 'Hello Vue!',
        data: 'Hello Data!',
        url: 'http://www.baidu.com',
        inputBindValue: '单向绑定元素变量，改变后下面边框不会修改',
        inputModelValue: '双向变量，改变后下面边框不会修改'
    }
})
app.$mount("#app");//mount挂载的意思
```

- data可以写为对象方式data:{key:value}，也能写成函数模式data:function(){return{key:value}}或简写为data(){return{key:value}}，但是不能使用箭头形式data:()=>{return{key:value}}，会导致当前对象不是Vued对象，会变成windows对象

```vue
var app = new Vue({
        data:function () {//data中供容器使用，值先写成一个对象
            console.log("函数式data",this)
            return {
                message: 'Hello Vue!',
                data: 'Hello Data!',
                url: 'http://www.baidu.com',
                inputBindValue: '单向绑定元素变量，改变后下面边框不会修改',
                inputModelValue: '双向变量，改变后下面边框不会修改'
            }

        }
    })
    var app = new Vue({
        data() {//data中供容器使用，值先写成一个对象
            console.log("函数式data",this)
            return {
                message: 'Hello Vue!',
                data: 'Hello Data!',
                url: 'http://www.baidu.com',
                inputBindValue: '单向绑定元素变量，改变后下面边框不会修改',
                inputModelValue: '双向变量，改变后下面边框不会修改'
            }

        }
    })
    var app = new Vue({
        data:()=>{//data中供容器使用，值先写成一个对象
            console.log("函数式data",this)
            return {
                message: 'Hello Vue!',
                data: 'Hello Data!',
                url: 'http://www.baidu.com',
                inputBindValue: '单向绑定元素变量，改变后下面边框不会修改',
                inputModelValue: '双向变量，改变后下面边框不会修改'
            }

        }
    })
    app.$mount("#app");
```

### 1.3.5 MVVM模型（Model-View-Viewmodel）

M:模型，Vue中对应data中的数据

V:视图：模板（Dom对象）

VM:视图模型：Vue对象

所以以后使用vm接收vue对象const vm= new Vue()。

vm中的属性，Vue的原型属性都可以在模板中使用。

## 1.4 数据代理

定义：通过一个对象代理对另一个对象中属性的操作。

通过vm对象(Vue对象，命名参考上一节)data对象属性进行操作，更方便。

使用Object.defineProperty的getter和setter完成。给对象添加属性的。

```vue
let num = 20;
//通过new对象的属性可以被修改，枚举，属性可以被删除
let person = {
    name:'张三',
    sex:'男'
}

Object.defineProperty(
    person,'age',{
        // value : num,//num赋值给age
        enumerable:true,//元素是否可以被枚举
        // writable:true,//属性是否能被修改
        // configurable:true,//属性能否被删除，可以使用控制到 delete person.age验证
        get(){//数据代理，num修改，age会跟着修改
            console.log('读取了age属性');
            return num
        },
        set(value){//反向代理，age修改后，num可以修改
            console.log('读取了age属性');
            num = value;
        }
    }
)
console.log(Object.keys(person));//这个方法表示枚举属性
```

Object.defineProperties也可以给对象添加属性，但是只能为如下方式，不能写get和set

```vue
Object.defineProperties(
    person,'age',{
        / value : num,//num赋值给age
         enumerable:true,//元素是否可以被枚举
         writable:true,//属性是否能被修改
         configurable:true,//属性能否被删除，可以使用控制到 delete person.age验证
    }
)
```

## 1.5 事件处理

v-on:当发生什么时执行什么。

用法v-on:click="执行方法"简写为@click="执行方法"。

执行方法，写在Vue实例中的methods里面，写在js里面读取不到，最好不要写再Vue实例中的data里，会进行数据代理，没有必要，会增加Vue的负担。

执行方法，用法时的执行方法可以有括号，也可以没括号。

如：v-on:click="showInfo()"，可以写成v-on:click="showInfo"

执行方法，如果没有自定义参数，那么第一个参数就是event参数。

如果定义了参数，event会被覆盖，可以使用$event占位符来找回。

如：v-on:click="showInfo($event,666)"

methods中的方法不能使用箭头方式=>函数，否则this时window对象，不是vue对象。

箭头函数的格式是     函数名:()=>{}，普通函数是   函数名:function(){}  或则   函数名(){}

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <button v-on:click="showInfo1">按钮点击1,没括号，带event参数</button>
    <button @click="showInfo2()">按钮点击2,带括号，没有参数</button>
    <button @click="showInfo3(66)">按钮点击3,查看用户参数,this对象是vue</button>
    <button @click="showInfo4($event,88)">按钮点击4,查看用户参数，带event对象</button>
    <button @click="showInfo5">按钮点击5,带event,this对象是windows</button>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示

    var vm = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            name: 'Vue课堂',
            // showInfo1:function(event,b,c,d) {
            //     console.log(event,b,c,d);//vue调用方法，会默认传一个Event进来
            //     console.log(event.target.innerHTML);//event.target获取点击的元素。
            //     alert("点击时间弹框");
            // }
        },
        methods:{
            showInfo1(event,b,c,d){
                console.log(event,b,c,d);//vue调用方法，会默认传一个Event进来
                console.log(event.target.innerHTML);//event.target获取点击的元素。
                alert("按钮点击1,没括号，带event参数");

            },
            showInfo2:function(event,b,c,d) {
                console.log(event,b,c,d);//
                alert("按钮点击2,带括号，没有参数");
            },
            showInfo3(event) {
                console.log(event);
                console.log(this);
                alert("按钮点击,查看用户参数，this对象是vue");
            },
            showInfo4(event,a) {
                console.log(event,a);//vue调用方法，会默认传一个Event进来
                alert("按钮点击4,查看用户参数，带event对象");
            }
            ,
            showInfo5:(event,a)=> {
                console.log(event,a);//vue调用方法，会默认传一个Event进来
                console.log(this);//event.target获取点击的元素。
                alert("按钮点击5,带event，this对象是windows");
            }
        }
    })

</script>
```
### 1.5.1 事件修饰符
Vue中的事件修饰符有，使用方法是在事件后面点修饰符，如@click.prevent，修饰符（不止事件修饰符）可以连用，如阻止@click.prevent.stop阻止系统默认和冒泡。
- prevent:常用，阻止默认事件，这个对应原生方法event.preventDefault();阻止默认行为,比如a标签的跳转行为
- stop:常用，阻止时间冒泡,两个包含容器，如果都有事件，那么里面容器点击时，会触发外面的事件，这就是冒泡。在内层加上之后，可以阻止外层冒泡。
- once:常用，事件只触发一次
- capture:使用事件的捕获模式,捕获阶段是由外向内的，冒泡阶段是由内往外，要让外层事件先执行，可以使用这个，需要在外层加。
- self:只有event.target是当前操作的元素时才触发事件。
- passive:事件的默认行为立即执行，无需等待事件回调执行完毕。//比如滚动条@wheel滚轴滚动，滚动时后面需要执行复杂的过程，处理完后才会移动滚动条，可以用这个先移动滚动条。
```vue 
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <a href="http://www.baidu.com" @click="showInfo1">这是一个跳转链接</a>
    <a href="http://www.baidu.com" @click="showInfo2">这是一个禁止跳转链接</a>
    <a href="http://www.baidu.com" @click.prevent="showInfo3">这是Vue禁止跳转链接</a>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示

    var vm = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            name: 'Vue课堂'
        },
        methods:{
            showInfo1(event) {
                alert("点击跳走了，是a标签默认行为。");
            },
            showInfo2(event) {
                event.preventDefault();//组织默认行为，原生方法
                alert("点击阻止默认a标签默认行为。");
            },
            showInfo3(event) {
                alert("点击Vue阻止默认a标签默认行为。");
            }
        }
    })

</script>
```
### 1.5.2键盘事件
Vue中提供了常用的键盘事件，这些键都是别名，在原生js中，这些键是大写开头的。  
用法，在元素上@keydown.enter 当按下的键盘是Enter时触发事件。  
1、Vue提供的常用键
- enter回车键
- delete删除和退格
- esc退出
- space空格
- tab换行 (需要配合keydown使用，如果使用keyup不起作用)
- up上
- down下
- left左
- right右

2、Vue中没有提供的键，可以使用原始的key值去绑定，特别注意如果键盘名时双单词，比如CapsLock对应的是caps-lock。  
3、系统修饰键比较特殊，如ctrl、alt、shift、meta（win键）
- 配合keyup使用：按下修饰键，再按下其他键，随后释放其他键，事件才触发。
- 配合keydown使用：正常触发。

4、也可以使用keyCode进行指定具体按键（不推荐了，已经废弃的标准，后面浏览器可能不支持，每个键盘的keyCode可能不一样）  
5、Vue.config.keyCodes.键别名=键码，可以自定义别名（也不推荐）

6、修饰符可以连用，比如keyup.ctrl.y只有是ctrl+y触发

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初始Vue</title>
    <script src="../js/vue.js"></script>
</head>
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <input type="text" @keyup.enter="showInfo1" placeholder="键盘事件">
    <input type="text" @keyup.tab="showInfo2" placeholder="tab keyup事件">
    <input type="text" @keydown.tab="showInfo3" placeholder="tab keydown事件">
    <input type="text" @keyup.ctrl="showInfo4" placeholder="系统修饰键keyup事件">
    <input type="text" @keydown.ctrl="showInfo5" placeholder="系统修饰键keydown事件">
    <input type="text" @keyup.caps-lock="showInfo6" placeholder="大写键盘keyup事件">
    <input type="text" @keydown.caps-lock="showInfo7" placeholder="大写键盘keydown事件">
    <input type="text" @keydown.13="showInfo8" placeholder="keyCode keydown事件">
    <input type="text" @keydown.huiche="showInfo9" placeholder="自定义键名keydown事件">
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    Vue.config.keyCodes.huiche=13;
    var vm = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            name: 'Vue课堂'
        },
        methods:{
            showInfo1(event) {
                console.log(event.key);
                alert("按了回车键");
            },
            showInfo2(event) {
                alert("tab keyup事件");
            },
            showInfo3(event) {
                alert("tab keydown事件");
            },
            showInfo4(event) {
                alert("系统修饰键keyup事件");
            },
            showInfo5(event) {
                alert("系统修饰键keydown事件");
            },
            showInfo6(event) {
                alert("大写键盘keyup事件");
            },
            showInfo7(event) {
                alert("大写键盘keydown事件");
            },
            showInfo8(event) {
                alert("keyCode keydown事件");
            }
            ,
            showInfo9(event) {
                alert("自定义键名keydown事件");
            }
        }
    })

</script>
</html>
```
## 1.6 计算属性

简单的操作可以用插值进行操作

```vue
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <input type="text" v-model="firstname"><br />
    <input type="text" v-model="secondName"><br />
    <span>{{firstname +'-'+ secondName}}</span><br />
    <span>{{firstname }}-{{secondName}}</span><br />
    <span>{{fullName}}</span><br /><!--打印这个函数-->
    <span>{{fullName()}}</span><br />
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            name: 'Vue课堂',
            firstname: '张',
            secondName: '三'
        },
        methods:{
            fullName() {
               return this.firstname +'-'+ this.secondName;
            }
        }
    })

</script>
```

### 1.6.1 计算属性概念及使用

概念：Vue中的data属性进行计算得到一个全新的属性。

使用方法：

Vue实例中，computed属性，计算出的属性值，get方法返回计算属性值。使用时，直接使用这个计算属性值。

get方法只有在第一次时或在属性值发生改变时调用。保证性能最优，如果属性值不修改，第一次加载后放入缓存中，提高效率，同时属性改变能保证数据一致性。

set方法时计算属性修改后调用。

get和set不能写成箭头函数=>，否则当前对象会变成windows

优势：有缓存机制，效率高，调式方便。

简写形式（只读取不修改）：    计算属性：function(){return 计算结果}；或则计算属性（）{return 计算结果}

```vue
computed: {
    computedFullName:{
       get(){
           return this.firstname +'-'+ this.secondName;
        }
    }
}
```

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <input type="text" v-model="firstname"><br />
    <input type="text" v-model="secondName"><br />
    <span>{{firstname +'-'+ secondName}}</span><br />
    <span>{{firstname }}-{{secondName}}</span><br />
    <span>{{fullName}}</span><br />
    <span>{{fullName()}}</span><br />
    <span>{{computedFullName}}</span><br />
    <span>{{easyComputedFullName}}</span><br />
    <span>{{easyComputedFullName2}}</span><br />
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            name: 'Vue课堂',
            firstname: '张',
            secondName: '三'
        },
        methods:{
            fullName() {
               return this.firstname +'-'+ this.secondName;
            }
        },
        computed: {
            computedFullName:{
               get(){
                   return this.firstname +'-'+ this.secondName;
                },
                set(value){//在控制台中可以设置这个值
            		alert(value);
        		}
            },
            easyComputedFullName:function (){
                return this.firstname +'-'+ this.secondName;
            },
            easyComputedFullName2(){
                return this.firstname +'-'+ this.secondName;
            }
        }
    })

</script>
```
## 1.7 监视属性

Vue中的watch对象，用于监听属性值（data和computed的属性都可以监听）改变。

- 当被监视的属性变化时，回调函数hander自动调用，进行相关操作。

- 监视的属性必须存在，才能进行监视，不存在也不会报错。

- 监视的两种写法，new Vue对象传入watch配置或通过Vue对象vm.$watch监视。

格式

```vue
watch:{
    需要监视的属性:{//
        immediate:true,//初始化就调用一次，默认为false
        handler(newValue,oldValue){//处理方法
            处理方法
        }
    }
}
或
vm.$watch(需要监视的属性,{//属性值需要使用引号引起来
        immediate:true,//初始化就调用一次
        handler(newValue,oldValue){//处理方法
            处理方法
        }
 }
        
```

- Vue中的watch默认不检测对象内部值的改变（一层结构）。

- 配置deep:true可以检测对象内部值改变（多层结构）。

- Vue自身检测内部值改变，但是watch默认不可以，程序员可以自己通过watch的deep:true开启。

格式

```vue
watch:{
    '属性名.子属性名':{//需要监视的属性,不能直接写numbers.a，必须用引号引起来，此方法监听一个属性
        handler(newValue,oldValue){//处理方法
            console.log("numbers的a改变了，"+newValue+",oldValue="+oldValue);
        }
    },
    属性名:{//需要监视的属性，
        deep:true,//深度监视，监听numbers对象内部所有的属性改变
        handler(newValue,oldValue){//处理方法
            console.log("numbers的属性改变了，"+newValue+",oldValue="+oldValue);
        }
    }
}
```

- 简写，只需要处理时可以简写

格式

```VUE
watch:{
    属性名(newValue,oldValue){
        console.log("watch简写的属性改变了，newValue="+newValue+",oldValue="+oldValue);
    }
}
或
vm.$watch('属性名',function(newValue,oldValue){//处理方法
            console.log("vm外部调用,watch简写的属性改变了,newValue="+newValue+",oldValue="+oldValue);
        }
    )
```



demo

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    今天天气很{{info}}<br />

    <button @click="changWeatcher">切换天气</button><br />
    <span @click="changeA()">number中的a改变了{{numbers.a}}</span><br />
    <span @click="changeB()">number中的b改变了{{numbers.b}}</span><br />
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',//el指定当前Vue为那个容器服务，值为css的选择器字符串。#app相当于document.getElementById(""),也可以赋值name
        data: {//data中供容器使用，值先写成一个对象
            name: 'Vue课堂',
            isHot: false,
            numbers:{
                a:1,
                b:0
            }
        },
        methods:{
            changWeatcher() {
                this.isHot= !this.isHot;
            },
            changeA() {
                this.numbers.a++;
            },
            changeB() {
                this.numbers.b++;
            }
        },
        computed: {
            info(){
               return this.isHot?'很热':'凉爽';
            }
        },
        watch:{
            info:{//需要监视的属性
                immediate:true,//初始化就调用一次
                handler(newValue,oldValue){//处理方法
                    console.log("天气改变了,newValue="+newValue+",oldValue="+oldValue);
                }
            },
            'numbers.a':{//需要监视的属性,不能直接写numbers.a，必须用引号引起来
                handler(newValue,oldValue){//处理方法
                    console.log("numbers的a改变了，"+newValue+",oldValue="+oldValue);
                }
            },
            numbers:{//需要监视的属性
                deep:true,//初始化就调用一次
                handler(newValue,oldValue){//处理方法
                    console.log("numbers的属性改变了，"+newValue+",oldValue="+oldValue);
                }
            },
            isHot(newValue,oldValue){
                console.log("watch简写的属性改变了，"+newValue+",oldValue="+oldValue);
            }
        }
    })
    vm.$watch('info',{//属性值需要使用引号引起来
        immediate:true,//初始化就调用一次
        handler(newValue,oldValue){//处理方法
            console.log("vm外部调用，天气改变了,newValue="+newValue+",oldValue="+oldValue);
        }
    })
    vm.$watch('isHot',function(newValue,oldValue){//处理方法
            console.log("vm外部调用,watch简写的属性改变了,newValue="+newValue+",oldValue="+oldValue);
        }
    )
</script>
```
### 1.7.1 计算属性与监视属性的区别及使用
- 正常的计算，使用computed更好。

- 需要开启异步计算时，watch才能完成，computed需要有返回值，所以无法完成异步计算。

- computed能完成的，watch都能完成。watch能完成的，computed不一定能完成。

- 被Vue管理的函数，写成普通函数，这样的this指向的才是vm或者组件实例对象。

- 不被Vue管理的函数（定时器的回调函数、ajax的回调函数等、promise的回调函数），最好时写成箭头函数，这样的this指向才是vm或者组件实例对象。

## 1.8 class绑定

1、格式：使用v-bind:class="vue变量或class名字符串"或简写:calss="Vue变量或class名字符串"

2、vue变量可以时字符串、数组、对象。

3、为字符串时，属性=classs名。适用于样式的类名不确定，需要动态指定。

4、为数组时，属性=[classs名，classs名]。适用于于绑定的样式个数不确定，名字也不确定。

4、为对象时，属性={classs名=false，classs名=true}，class名属性为false时不使用这个样式，为true时使用这个样式。适用于绑定的的样式个数确定、名字也确定，但要动态决定用不用。

### 1.8.1 内联样式 style

1、格式：使用v-bind:style="vue变量对象或数组"或简写:style=vue变量对象或数组"

2、对象属性如果原生html带中横线，使用大写替代，驼峰命名。属性值为字符串，即单引号引起来。

列子：

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初始Vue</title>
    <script src="../js/vue.js"></script>
    <style>
        .backgroupYell{
            background-color: yellow;
        }
        .backgroupGreen{
            background-color: green;
        }
        .fontClor{
            color: red;
        }
    </style>
</head>
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <!--字符串-->
    <div  :class="'fontClor'">{{classChange}}</div>
    <!--动态绑定字符串-->
    <div  :class="changeColor" @click="changeBackgroudColor">动态绑定字符串</div>
    <!--数组,如果数组不是字符串即不是单引号引起来，则表示变量，需要时Vue中找对应的属性-->
    <div  :class="['backgroupYell','fontClor']" @click="changeBackgroudColor">数组</div>
    <!--动态数组-->
    <div  :class="arrClass" @click="changeBackgroudColor">动态数组</div>
    <!--对象-->
    <div  :class="{backgroupYell:true,fontClor:false}" @click="changeBackgroudColor">对象</div>
    <!--变量对象-->
    <div  :class="classObject" @click="changeBackgroudColor">变量对象</div>

    <!--绑定stryle对象-->
    <div  :style="{backgroundColor:'yellow'}">绑定style对象</div>

    <!--绑定style对象变量-->
    <div  :style="styleObject">绑定style对象变量</div>

    <!--绑定style数组-->
    <div  :style="styleArr" >绑定style数组变量</div>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            classChange:'样式改变',
            changeColor:'backgroupGreen',
            arrClass:['backgroupYell','fontClor'],
            classObject:{
                backgroupYell:false,
                fontClor:true
            },
            styleObject:{
                color:'red',
                backgroundColor:'yellow'
            },
            styleArr:[
                {color:'green'},
                {backgroundColor:'yellow'},
                {
                    fontSize:'20px',
                    fontWeight:'bold'
                }
            ]
        },
        methods:{
            changeBackgroudColor() {
              this.changeColor = 'backgroupYell'
            }
        }
    })

</script>
</html>
```

## 1.9 条件渲染
### 1.9.1 v-show

格式：v-show="false"

元素隐藏于显示。v-show="只要返回时布尔值即可"

适用场景切换频率较高的场景，直接隐藏元素。



### 1.9.2 v-if

v-if="false"

元素移除，v-if="只要返回时布尔值即可"

v-else-if="false"，需要于v-if一起用，而且元素要连续，不能被打断

v-else-if="只要返回时布尔值即可"

v-else，需要于v-if一起用，而且元素要连续，不能被打断(必须联系，跳任何标签都不行)

<template标签可以于v-if一起使用，用于需要隐藏多个元素，防止打断的问题。只能于v-if使用

适用于：切换频率较低的场景，直接移除不展示的元素。

列子：

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初始Vue</title>
    <script src="../js/vue.js"></script>
</head>
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <div v-show="showElment"  @click="changeShow">点击隐藏</div>
    <div v-if="deleteElment"  @click="changeDelete">点击删除节点</div>

    <div v-if="false">开始判断</div>
    <div v-else="true">else判断</div>

    <div v-if="false">开始打断判断</div>
    <span>打断元素</span>
    <div v-else="true">else打断判断</div>

    <template v-if="deleteElment">
        <h2>第1标题</h2>
        <h2>第2标题</h2>
        <h2>第3标题</h2>
    </template>
    
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            showElment:true,
            deleteElment:true
        },
        methods:{
            changeShow() {
              this.showElment = false
            },
            changeDelete(){
                this.deleteElment = false
            }
        }
    })

</script>
</html>
```
## 1.10 列表渲染
### 1.10.1 使用for循环进行列表渲染

用法v-for="(value,index) in object"  index为可选参数。in可以使用of替换，object可以是数组（value为数组的一个元素）、对象（value为对象属性）、字符串（value为单个字符串）、数字（value为从1开始的数字）。index为索引值

写法：

v-for="value in object"

v-for="(value,index) in object"

v-for="value,index of object"//不建议这样写，有些编辑器会报错

v-for="value,index in object"//不建议这样写，有些编辑器会报错

for循环需要搭配:key使用，表示唯一标识，不写则VUE默认是index。

格式：v-for="(value,index) in object"  :key="唯一标识"。

### 1.10.2 key的作用

- key不会出现在真是DOM中。
- key是虚拟DOM的标识，当数据发生变化时，Vue会根据新数据生成新的虚拟DOM，与旧的虚拟DOM进行比较，通过key查找。
- 若旧的DOM中内容没变，直接使用之前的真是DOM，若发生变化，生成新的DOM，替换之前的真是DOM。
- 旧的DOM中没有找到相同的key的虚拟DOM，则创建新的dom，然后渲染到页面中。

### 1.10.3 用index作为key引发的问题。

- 若对数据进行逆序添加、逆序删除破坏顺序操作，会产生没有必要的真实DOM更新，效率低。
- 如果结构中还包含输入类的DOM，如input，会产生错误的DOM更新，界面有问题。

### 1.10.4 如何选择key

- 使用每条数据的唯一表示作为key，如id
- 如果没有对数据的逆序添加、逆序删除等破坏顺序操作，可以使用index作为key没有问题。

原理：

旧的虚拟DOM

```
<li key="0">
   张三--18
    <input type="text" />
</li>
<li key="1">
   李四--19
    <input type="text" />
</li>
<li key="2">
   王五--20
    <input type="text" />
</li>
```

在数组头部插入一个属性时，新的虚拟DOM发生改变。通过key去查找，每个对应的文本值都有变化，需要重新替换生成新的DOM，而虚拟DOM中input未发生变化，直接引用页面的DOM，所以页面中DOM有输入值后，虚拟DOM中无法判断，造成页面显示错乱。

```
<li key="0">
   王二麻子--40
    <input type="text" />
</li>
<li key="1">
   张三--18
    <input type="text" />
</li>
<li key="2">
   李四--19
    <input type="text" />
</li>
<li key="3">
   王五--20
    <input type="text" />
</li>
```

demo

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初始Vue</title>
    <script src="../js/vue.js"></script>

</head>
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <h2>遍历数组一个参数写法</h2>
    <li v-for="person in persons">
        {{person.name}}--{{person.age}}
    </li>

    <h2>遍历数组两个参数写法，带括号，建议这样用</h2>
    <li v-for="(person,index) in persons">
        {{person.name}}--{{person.age}}---{{index}}
    </li>

    <h2>遍历数组两个参数写法，不带括号，不建议这样用，有些编译器会报错</h2>
    <li v-for="person,index in persons">
        {{person.name}}--{{person.age}}---{{index}}
    </li>

    <h2>遍历数组两个参数写法，带括号，key指定id,一般是这样用</h2>
    <li v-for="(person,index) in persons" :key="person.id">
        {{person.name}}--{{person.age}}---{{index}}
    </li>

    <h2>遍历数组两个参数写法，使用of </h2>
    <li v-for="(person,index) of persons" :key="person.id">
        {{person.name}}--{{person.age}}---{{index}}
    </li>

    <h2>遍历对象</h2>
    <li v-for="(attributeCar,index) of car" :key="index">
        {{attributeCar}}---{{index}}
    </li>

    <h2>遍历字符串 </h2>
    <li v-for="(charStr,index) of str" :key="index">
        {{charStr}}---{{index}}
    </li>

    <h2>遍历数组 </h2>
    <li v-for="(number,index) in 5" :key="index">
        {{number}}---{{index}}
    </li>

    <h2>key的作用</h2>

    <button @click.once="addPerson" >添加人员</button>
    <h2>index作为key，在input输入内容后，添加内容，会导致页面错乱,因为虚拟dom按照key去索引，重新生成，input虚拟dom没变，直接使用</h2>
    <li v-for="person in persons" :key="index">
        {{person.name}}--{{person.age}}
        <input type="text" />
    </li>
    <h2>id作为key，在input输入内容后，添加内容，功能正常</h2>
    <li v-for="person in persons" :key="person.id">
        {{person.name}}--{{person.age}}
        <input type="text" />
    </li>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            persons:[
                {id:'01',name:'张三',age:18},
                {id:'02',name:'李四',age:19},
                {id:'03',name:'王五',age:20}
            ],
            car:{
                color:'红色',
                age:'三年'
            },
            str:'hello word'
        },
        methods:{
            addPerson(){
                this.persons.unshift({id:'04',name:'王二麻子',age:40})
            }
        }

    })

</script>
</html>
```

### 1.10.5 列表过滤

使用watch或这compute进行计算过滤数组

indexOf当值时空字符串时，返回的时0，不存在的值时，返回的是-1。

watch第一次加载列表时，需要初始化一次，immediate:true，才能显示出列表，否则只有在页面输入后，再删除才能显示完全列表。

watch和computed都能实现时，优先使用computed.



demo

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <input type="text" v-model="keyWord"/>

    <li v-for="person in filterPersons">
        {{person.name}}--{{person.age}}
    </li>

    <input type="text" v-model="computedKeyWord"/>
    <li v-for="person in computedPersons">
        {{person.name}}--{{person.age}}
    </li>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    var vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            keyWord:"",
            computedKeyWord:"",
            persons:[
                {id:'01',name:'马冬梅',age:18},
                {id:'02',name:'周冬雨',age:19},
                {id:'03',name:'周杰伦',age:20},
                {id:'04',name:'温兆伦',age:30}
            ],
            filterPersons:[]
        },
        watch:{
            keyWord:{//需要监视的属性
                immediate:true,//初始化就调用一次
                handler(newValue,oldValue){//处理方法
                    this.filterPersons = this.persons.filter((person)=>{
                        return person.name.indexOf(newValue) !== -1;
                    })
                }
            }
        },
        computed:{
            computedPersons(){
                return  this.persons.filter((person)=>{
                    return person.name.indexOf(this.computedKeyWord) !== -1;
                })
            }
        }

    })

</script>
```

### 1.10.6 列表排序

使用数组sort进行排序，arr.sort((value1,value2)=>{return value1-value2})返回正序，否则返回倒序。数组排序后还是在原来数组中，不用接收，与filter不同，filter会产生一个新数组。sort不会产生新数组。

demo

```
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>


    <input type="text" v-model="computedKeyWord"/>
    <input type="button"  @click=" sortType = 1" value="按年龄升序" />
    <input type="button"  @click=" sortType = 2" value="按年龄降序" />
    <input type="button"  @click=" sortType = 0" value="回到元顺序" />
    <li v-for="person in computedPersons">
        {{person.name}}--{{person.age}}
    </li>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    let vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            sortType:0,
            computedKeyWord:"",
            persons:[
                {id:'01',name:'马冬梅',age:18},
                {id:'02',name:'周冬雨',age:23},
                {id:'03',name:'周杰伦',age:20},
                {id:'04',name:'温兆伦',age:17}
            ]
        },
        computed:{
            computedPersons(){
                let filterPersonsArr = this.persons.filter((person)=>{
                    return person.name.indexOf(this.computedKeyWord) !== -1;
                })
                if(this.sortType){
                    filterPersonsArr.sort((person1,person2)=>{
                        return this.sortType===1 ? person1.age-person2.age :person2.age-person1.age;
                    });
                }
                return filterPersonsArr;
            }
        }

    })

</script>
```

### 1.10.7 监视数据原理

VUE通过数据代理，进行数据监视，当数据发生变化时，原生js调用set修改对应的属性值，vue在set方法中添加了虚拟DOM操作。

简单实现Demo

```vue
<script>
    let data ={
        name:'张三',
        age:18
    }
   /* Object.defineProperty(data,'name',{
        get(){
            //不能这样使用，会报异常 Maximum call stack size exceeded at Object.get
            //获取data的name时，会调用get，get里面的data.name还会调用get，导致死循环，超出最大栈大小
            return data.name;
        },
        set(val){
            return data.name = name;
        }
    })*/
    function Observer(obj){
        const keys = Object.keys(obj);
        keys.forEach(
            (k)=>{
                //往当前的Observer对象添加属性，将值通过传入的obj获取，然后设置回obj。这样就避免了死循环。VUE采用递归方式设置的。
                Object.defineProperty(this,k,{
                    get(){
                         return obj[k];
                    },
                    set(val){
                        return obj[k] = val;
                    }
                })
            }
        )
    }
    const  obs = new Observer(data);
</script>
```

具体参考原生js的Object.defineProperty

1、Vue会监视data下面所有层次的数据。

2、如何检测对象中的数据？

- 通过原生js的Object.defineProperty的setter实时监视，且要在new Vue时传入要检测的数据。

- 对象中后追加的属性，Vue默认不做响应式处理（响应式表示vm中的数据修改，页面跟着修改）。即vm.name='李四'直接赋值的无法做数据代理，因为没有做数据代理。

- 如需给后添加的属性做响应式（添加数据代理），请使用如下API

  Vue.set(target,propertyName/index,value)或

  vm.$set(target,propertyName/index,value)

3、如何监视数组中的数据？

通过包裹数组更新元素的方法实现，本质做了两件事

- 调用原生对应的方法对数组进行更新
- 重新解析模板，进而更新页面
- 直接赋值给数组下标，无法被监视，不会引起页面数据更新，所以页面无法更新。

在Vue修改数组中的某个元素一定要使用如下方法

- API：push()、pop()、shift()、unshift()、splice()、sort()、reverse()。
- Vue.set()或vm.$set()
- filter()、concat()、slice()不会变更原始数组，而总是返回一个新数组，所以无法做到监听，如果需要更新，可以用新数组替换旧数组

5、VUE的set局限性

- Vue.set()或vm.$set()不能给vm（vm对象上）或vm的根数据（vm._data）对象添加属性

  。

- 即不能直接添加根属性Vue.set( name,0,'开车');

6、数据劫持

所谓数据劫持，就是你原生数据被劫持转换成另外对象，像Vue中的data属性值，在修改时，被vue的_data对象代理，添加了setter参数，数据在修改时，通过setter劫持进行修改，并添加的页面的操作。这就是数据劫持。

demo

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <button @click="student.age++">年龄+1岁</button>
    <button @click="addSex">添加性别属性，默认值为男</button>
    <button @click="updateSex">修改性别</button>
    <button @click="addFriend">在列表首位添加一个朋友</button>
    <button @click="updateFirstFriendName">修改第一个朋友的名字为张三</button>
    <button @click="addHobby">添加一个爱好</button>
    <button @click="updateFirstHobby">修改第一个爱好为:开车</button>
    <button @click="fileterFirstHobby">过滤爱好</button>
    <h2>姓名:{{student.name}}</h2>
    <h2>年龄:{{student.age}}</h2>
    <h2 v-if="student.sex">年龄:{{student.sex}}</h2>
    <h2>爱好:</h2>
    <ul>
        <li v-for="(hobby,index) in student.hobbys" :key="index">
            {{hobby}}
        </li>
    </ul>
    <h2>朋友们:</h2>
    <ul>
        <li v-for="(friend,index) in student.friends" :key="index">
            {{friend.name}}--{{friend.age}}
        </li>
    </ul>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    let vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            student:{
                name:'tom',
                age:15,
                hobbys:['抽烟','喝酒','烫头'],
                friends:[
                    {name:'tony',age:35},
                    {name:'jieke',age:36}
                ]
            }
        },
        methods:{
            addSex(){
                // this.student.sex = '男';此方法为直接在sex上添加属性，没有getter和setter无法进行数据响应
                // Vue.set( this.student,'sex','男');
                vm.$set( this.student,'sex','男');
            },
            updateSex(){
                this.student.sex = '女';
            },
            addFriend(){
                this.student.friends.unshift( {name:'jierry',age:32});
            },
            updateFirstFriendName(){
                this.student.friends[0].name='张三';
            },
            addHobby(){
                this.student.hobbys.push( '学习');
            },
            updateFirstHobby(){
                // this.student.hobbys[0] = '开车';此方法无法修改页面，因为是直接赋值，VUE无法做代理
                // this.student.hobbys.splice(0,1,'开车');
                // vm.$set( this.student.hobbys,0,'开车');
                // this.$set( this.student.hobbys,0,'开车');
                Vue.set( this.student.hobbys,0,'开车');
            },
            fileterFirstHobby(){
                this.student.hobbys = this.student.hobbys.filter((hobby)=>{
                    return hobby !== '喝酒';
                });
            }
        }

    })

</script>
```
## 1.11 获取表单输入
1、文本输入框，input   type="text"，则v-model收集的就是用户输入的value值

2、单选框，type="radio"，v-model收集的value值需要标签配置。

3、复选框，type="checkbox"，则v-model收集的value默认值是checked是否勾选的布尔值

- 如果配置配置了value标签数据，收集的属性是数组，则收集的是value值数组。
- 如果不是数组，收集的是value值是checked是否勾选的布尔值。
- 复选框还可以配置 `true-value` 和 `false-value`来定义是否选中时的值

4、v-model的三个修饰符

- lazy:失去焦点再收集数据
- number:输入字符串转为数字
- trim:去掉首位空格

5、select  绑定值可以是字符串，也可以是数组，有数组的原因可能是有多选。

6、`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。通过VUE的 `data` 声明绑定值的初始值。



demo

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
   <form>
       <label for="name">名字：</label>
       <input type="text" id="name" v-model="name">
       {{name}}
       <hr/>
       <label for="phone">手机号：</label>
       <input type="number" id="phone" v-model.number="phone">
       {{phone}}
       <hr/>
       <label for="qukongge">去空格：</label>
       <input type="text" id="qukongge" v-model.trim="qukongge">
       {{qukongge}}
       <hr/>

       <label >性别：</label>
       <input type="radio" name="sex" v-model="sex" value="男">男
       <input type="radio" name="sex" v-model="sex"  value="女">女
       {{sex}}
       <hr/>

       <label>爱好：</label>
       <input type="checkbox" name="hobby" v-model="hobby" value="抽烟">抽烟
       <input type="checkbox" name="hobby" v-model="hobby"  value="喝酒">喝酒
       <input type="checkbox" name="hobby" v-model="hobby"  value="烫头">烫头
       <input type="checkbox" name="hobby" v-model="hobby"  value="泡妞">泡妞
       {{hobby}}
       <hr/>

       <label>朋友：</label>
       <select v-model="friend">
           <option value="张三">张三</option>
           <option value="李四">李四</option>
           <option value="王五">王五</option>
       </select>
       {{friend}}
       <hr/>
       <label>备注：</label>
       <textarea v-model.lazy="message" placeholder="add multiple lines"></textarea>
       {{message}}
       <hr/>
       <input type="checkbox" name="hobby" v-model="accept">同意接受协议
       <hr/>
       <input type="checkbox"  v-model="toggle" true-value="yes" false-value="no">自定义ture false value值
       {{toggle}}
   </form>
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    let vm = new Vue({
        el: '#app',
        data: {
            name:"张三",
            phone:123,
            qukongge:"    前后都有空格   ",
            sex:'男',
            //hobby:''如果接收是字符串，选择时的value是checkbox的checked boolean值，会导致全部选择或不选中。
            hobby:[],
            friend:'张三',
            //friend:['张三','李四'],//如果接收是字符串，就是select值，如果多选可以使用数组
            message:'',
            accept:true,
            toggle:''
        }
    })

</script>
```
## 1.12 过滤器
- 过滤器写法，与计算属性、methods差不多。实例中使用filters:{方法名(value,){return 返回值}}。

- 插值语法中 竖线 空格 filters名字。多个过滤器可以叠加，值从前往后传递。也就是time传递给

  fileterFormatTime，fileterFormatTime返回的结果再传递给secondFilter。filters的第一个参数永远是上一个传递过来的值，不管你方法中自己的参数写在第几位

- 在实例中的filters只能在当前容器使用

- 使用Vue.filter可以全局使用。格式为Vue.filter(‘过滤器名字’，function (value){return 返回值})

- 可以与v-bind使用，但是不能与v-model使用

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>


    <h2>{{time}}</h2>
    <h2>{{formatTime}}</h2>
    <h2>{{getFormatTime()}}</h2>
    <h2>{{time | fileterFormatTime | secondFilter('param')}}</h2>
    <h2> 全局过滤器：{{time | sliceFiveWords }}</h2>
    <input  :value="time  | sliceFiveWords " type="text" />
    <input  v-bind:value="time  | sliceFiveWords " type="text" />
    <input  v-model="time" type="text" />
</div>

</body>
<script>
    Vue.config.productionTip = false;//关闭生产提示
    Vue.filter('sliceFiveWords',function (value){
        return value.slice(0,5)
    });
    let vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            time:'12345678abc'
        },
        computed:{
            formatTime(){
                return this.time.toUpperCase();
            }
        },
        methods:{
            getFormatTime(){
                return this.time.slice(0,9);
            }
        },
        filters:{
            fileterFormatTime(value){
                return value.slice(0,4);
            },
            secondFilter(value,parameter){
                return value+parameter;
            }
        }

    })

</script>
```
## 1.13 内置指令
v-text，使用方式在html元素中加入 v-text=""，定义文本内容，会替换原有元素中文件内容。

v-html，使用方式在html元素中加入 v-html=""，定义html内容，替换元素中html内容。这种会有安全性问题，比如xss攻击。

v-cloak，使用方式在html元素中加入 v-cloak，没有值。解决html还未被Vue解析时产生的插值语法直接展示问题，比如加载的Vue.js网速慢，还未加载回来时，页面会呈现插值语法文本，显示不够友好。当VUE加载完成时，会删掉标签中的v-cloak，呈现对应内容。v-cloak配合css使用，比如当VUE还未加载时，有v-cloack标签的html元素置为display:none，则可以避免用户看到插值语法文本，Vue加载完成时，会重新解析html，删除掉v-cloak标签，保证页面呈现给用户。

v-once，使用方式在html元素中加入 v-once，没有值。初次动态渲染，就视为静态内容了，vue的值改变不跟着改变。与事件那个不一样，事件是在指令后加。

v-pre，使用方式在html元素中加入 v-pre，没有值。用于告知Vue这个元素不用解析，提高解析页面效率。

demo

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>初始Vue</title>
    <script src="../js/vue.js"></script>
    <style>
        [v-cloak]{
            display: none;
        }
    </style>
</head>
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>


    <h2 v-text="textStr">页面初始值</h2>
    <h2 v-html="htmlText">页面初始值</h2>
    <h2 >{{textStr}}</h2>
    <h2 v-cloak>{{textStr}}</h2>
    <h2 v-once >n初始值{{n}}</h2>
    <h2>n当前值{{n}}</h2>
    <button @click="n++">点击n加1</button>

    <h2 v-pre>跳过当前元素解析{{textStr}}</h2>
</div>

</body>

<script>
    Vue.config.productionTip = false;//关闭生产提示
    Vue.filter('sliceFiveWords',function (value){
        return value.slice(0,5)
    });
    let vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            textStr:'<a>这是要给文本内容</a>',
            htmlText:'<a href="#">这是要给html内容</a>',
            n:1
        }

    })

</script>
<!--<script src="../js/vue.js"></script>--><!-- 需要验证v-cloak 需要将js放在这里加载 -->
</html>
```
## 1.14 自定义指令
自定义指令

- 以V-开头，指定全是小写的，不能使用驼峰命令，Vue无法解析，多个单词使用-链接，directives指令名带-就需要使用引号引起来。
- 自定义指令在初始化或者模板被改变时被调用解析，不仅时它的值被修改是被调用，容器的值修改就会被调用。也就是当前实例容器中的元素重新解析时，你的自定义指令就会重新被解析调用一次。无修改则不会被调用。
- 指令中的this对象时window
- 全局自定义指令，使用Vue.directive。格式为Vue.directive(‘自定义指令名’，function (element,binding){return 返回值})
- 局部自定义指定，在实例中使用directives。如下格式


```js
directives:{
	<!--指令名是去掉v-的自定义名字-->
	<!--写法一，方法模式，简写-->
	指令名(element,binding){
		<!--element是html标签对象-->
		<!--binding是传入的指定值-->
	},
	<!--写法二，对象模式-->
	指令名:{
                //元素绑定时被调用，名字不能写错，不能修改
                bind(element,binding){
                    <!--element是html标签对象-->
		            <!--binding是传入的指定值-->

                },
                //指令元素被插入页面时调用，名字不能写错，不能修改
                inserted(element,binding){
                     <!--element是html标签对象-->
		            <!--binding是传入的指定值-->
                },
                //元素更新时被调用，名字不能写错，不能修改
                update(element,binding){
                     <!--element是html标签对象-->
		            <!--binding是传入的指定值-->
                }
            }
}
```

Demo

```vue
<body>
<div id="app">
    <h2>欢迎来到{{name}}学习</h2>
    <button @click="b++">模板解析时big指定会调用{{b}}</button>

    <h2>n当前值{{n}}</h2>
    <button @click="n++">点击n加1</button>
    <h2 >n值放大10倍<span v-big="n"></span></h2>
    <input v-focus="n" />
    <input v-focus-first="n" />
</div>

</body>

<script>
    Vue.config.productionTip = false;//关闭生产提示
    Vue.filter('sliceFiveWords',function (value){
        return value.slice(0,5)
    });
    let vm = new Vue({
        el: '#app',
        data: {
            name: 'Vue课堂',
            n:1,
            b:10
        },
        directives:{
            big(element,binding){
                console.log("big指定元素调用")
                element.innerText = binding.value*10;
            },
            focus(element,binding){
                element.value = binding.value;
                //这样操作会导致第一次获取不了焦点。因为第一次元素还未放如html中，就加载获取焦点，再添加到tml中，导致失败
                //第二次元素已经appendChild放入html中，直接修改html中属性，就可以获取焦点了。
                element.focus();
            },
            'focus-first':{
                //元素绑定时被调用
                bind(element,binding){
                    element.value = binding.value;

                },
                //指令元素被插入页面时调用
                inserted(element,binding){
                    element.focus();
                },
                //元素更新时被调用
                update(element,binding){
                    element.value = binding.value;
                    element.focus();
                }
            }
        }
    })

</script>
```
## 1.15 生命周期
### 1.15.1 生命周期

详见https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90

1、又名：生命周期回调函数、生命周期函数、生命周期钩子

2、生命是什么周期，Vue在关键时刻帮我们调用的一些特殊名称的函数。

3、生命周期函数名不可以更改，但函数的具体内容是程序员根据需求编写的。

4、生命周期函数中的this执行的是vm或者组件实例对象。

### 1.15.2 生命周期函数

1、beforeCreate(){} 初始化生命周期、事件、但是数据代理还未开始，无法通过vm访问data中数据、methods中的方法
2、created(){}数据侦听、计算属性、方法、事件/侦听器的回调函数加载完成，可以通过vm访问data中数据、methods中的方法
3、beforeMount(){}解析完模板，生成了虚拟DOM在内存中，页面还不能显示解析好的内容，这里操作的dom最终都不生效。
4、mounted(){}页面呈现Vue编译后的Dom，操作Dom均有效，但是尽可能避免。这里可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作
5、beforeUpdate(){}当数据改变时，还未放入页面
6、updated(){}数据已经改变，放入页面
7、beforeDestroy(){}vue实例销毁前，所有的data、methods、指令等都是可用状态，但是对数据的修改不会呈现在页面上了，vue不再解析模板。一般关闭定时器、取消订阅消息、解绑自定义事件等收尾工作
8、destroyed(){}vue实例销毁时调用

9、activated(){}被 keep-alive 缓存的组件激活时调用。
10、deactivated(){}被 keep-alive 缓存的组件失活时调用。

11、errorCaptured(){} 2.5.0版本新增，在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

### 1.15.3 生命周期销毁函数vm.$destroy()

完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器(自定义事件)。



demo

```vue
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="../js/vue.js"></script>
</head>
<body>
    <div id="app">
        <!--style是键值对形式，opacity本来就属于style的，可以简写为opacity，单需要用花括号引起来-->
        <h2 :style="{opacity}">{{name}}</h2>
       <!-- {{changeOpacity()}}-->
        <h2 :style="opacityObj">{{name}}</h2>
        <button @click="destroyedVue">销毁Vue</button>
    </div>
</body>
<script>
    Vue.config.productionTip = false;
    const  vm = new Vue({
        el:"#app",
        data:{
            name:"欢迎学习Vue",
            opacity:1,
            opacityObj:{
                opacity:1
            }
        },
        methods:{
            /*不能使用methods方法进行调用一次，因为Vue在使用时，监测到
            opacity改变，会重新解析app模板的内容，重新调用methods方法，导致重复执行*/
            /*changeOpacity(){
                console.log("changeOpacity方法被调用")
                setInterval(()=>{
                    vm.opacity -= 0.01;
                    if(vm.opacity<0){
                        vm.opacity=1;
                    }
                },16);
            }*/
            destroyedVue(){
                this.$destroy();
            }
        },
        mounted(){
            console.log("mounted");
            console.log(this);
            setInterval(()=>{
                this.opacity -= 0.01;
                if(this.opacity<0){
                    this.opacity=1;
                }
            },16);
            debugger
        },
        beforeCreate(){
            console.log("beforeCreate");
            console.log(this);
            debugger
        },
        created(){
            console.log("created");
            console.log(this);
            debugger
        },
        beforeMount(){
            console.log("beforeMounte");
            console.log(this);
            debugger
        }/*,
        beforeUpdate(){
            console.log("beforeUpdate");
            console.log(this);
            debugger
        },
        updated(){
            console.log("updated");
            console.log(this);
            debugger
        }*/,
        beforeDestroy(){
            console.log("beforeDestroy");
            console.log(this);
            debugger
        },
        destroyed(){
            console.log("destroyed");
            console.log(this);
            debugger
        }


    });
    /*这种方式可以实现动态变化，但是使用Vue了这种不太好*/
    /*setInterval(()=>{
        vm.opacity -= 0.01;
        if(vm.opacity<0){
            vm.opacity=1;
        }
    },16);*/
</script>
</html>
```

beforeDestroy和destroyed函数中操作数据，页面不会再更新。

尽量不要主动调用vm.$destroy()，销毁函数可以用其他组件进行调用，他杀的情况。

生命周期图中只显示了8个函数，还有3个函数是路由情况的。一共11个。

### 1.15.4 常用生命周期钩子：

mounted:发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。

beforeDestroy：清楚定时器、解绑自定义事件、取消订阅消息等收尾工作。

### 1.15.5  销毁Vue实例：

- 销毁后借助Vue开发者工具看不到任何信息。
- 销户后自定义事件会消失，但原生DOM事件依然有效。
- 一般不会再beforeDestroy操作数据，因为即使操作了，也不会再触发更新流程了。

