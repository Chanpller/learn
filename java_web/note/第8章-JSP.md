# 第8章-JSP

## 8.1 什么是 jsp

- jsp 的全换是 java server pages。Java 的服务器页面。
- jsp 的主要作用是代替 Servlet 程序回传 html 页面的数据。

* 因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高

Servlet 回传 html 页面数据的代码：

```java
public class PringHtml extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException,
    IOException {
        // 通过响应的回传流回传 html 页面数据
        resp.setContentType("text/html; charset=UTF-8");
        PrintWriter writer = resp.getWriter();
        writer.write("<!DOCTYPE html>\r\n");
        writer.write(" <html lang=\"en\">\r\n");
        writer.write(" <head>\r\n");
        writer.write(" <meta charset=\"UTF-8\">\r\n");
        writer.write(" <title>Title</title>\r\n");
        writer.write(" </head>\r\n");
        writer.write(" <body>\r\n");
        writer.write(" 这是 html 页面数据 \r\n");
        writer.write(" </body>\r\n");
        writer.write("</html>\r\n");
        writer.write("\r\n");
    }
}
```

jsp 回传一个简单 html 页面的代码：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
    	<title>Title</title>
    </head>
    <body>
    这是 html 页面数据
    </body>
</html>
```

* jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟访问 html 页面一样。

* 在 web 目录下有如下的文件：

  web 目录

  ​       a.html 页面    访问地址是 =======>>>>>> http://ip:port/工程路径/a.html

  ​      b.jsp 页面       访问地址是 =======>>>>>> http://ip:port/工程路径/b.jsp

* jsp页面需要通过服务器访问，直接打开是不行的。

## 8.2 jsp 的本质是什么。

* jsp 页面本质上是一个 Servlet 程序。

* jsp通过解析后，生成继承HttpJsoBase的一个类，HttpJspBase继承HttpServlet，所以本质上是一个Servlet程序。

* ```
  public abstract class HttpJspBase extends HttpServlet implements HttpJspPage
  ```

* 第一次访问 jsp 页面的时候（不访问不生效）。Tomcat 服务器会帮我们把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成为.class 字节码程序。我们打开 java 源文件发现其里面的内容是：（打开方式，通过tomcat启动日志，找到CATALINA_BASE启动日志对应的路径下面的work\Catalina\localhost\项目名\org\apache\jsp可以找到生成的jsp的java类）

TestJsp.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Administrator
  Date: 2023/9/15
  Time: 22:22
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    这是一个测试的jsp页面
</body>
</html>

```

生成的TestJsp_jsp.java内容是

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.0.26
 * Generated at: 2023-09-15 14:32:13 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class TestJsp_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

final java.lang.String _jspx_method = request.getMethod();
if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
return;
}

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>Title</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("    这是一个测试的jsp页面\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
```

## 8.3 jsp 头部的 page 指令

* jsp 的 page 指令可以修改 jsp 页面中一些重要的属性，或者行为。
* 一个jsp页面可以写多个page指令标签。
* 格式为 <%@ page %>

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

* language 属性表示 jsp 翻译后是什么语言文件。暂时只支持 java。
* contentType 属性表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值
* pageEncoding 属性表示当前 jsp 页面文件本身的字符集，格式不对会导致乱码。
* import 属性 跟 java 源代码中一样。用于导包，导类。
* autoFlush 属性设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。关闭写入的数据大于缓冲区时，程序报错。
* buffer 属性设置 out 缓冲区的大小。默认是 8kb
* errorPage 属性设置当 jsp 页面运行时出错，自动跳转去的错误页面路径
* isErrorPage 属性设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以获取异常信息，即获取到Exception对象。
* session 属性设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。
* extends 属性设置 jsp 翻译出来的 java 类默认继承谁。 

TestJsp.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Administrator
  Date: 2023/9/15
  Time: 22:22
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="ISO-8859-1"
         import="java.lang.String"
         import="java.util.Date"
         autoFlush="false"
         buffer="1kb"
         errorPage="index.jsp"
         isErrorPage="true"
         session="false"
         extends="javax.servlet.HttpServlet"
%>
<html>
<head>
    <title>Title</title>
    <%=new Date() %>
</head>
<body>
    这是一个测试的jsp页面
</body>
</html>

```



生成的TestJsp_jsp.java内容是

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.0.26
 * Generated at: 2023-09-15 15:05:34 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.lang.String;
import java.util.Date;

public final class TestJsp_jsp extends javax.servlet.HttpServlet
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = new java.util.HashSet<>();
    _jspx_imports_classes.add("java.util.Date");
    _jspx_imports_classes.add("java.lang.String");
  }

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

    final javax.servlet.jsp.PageContext pageContext;
    java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);
    if (exception != null) {
      response.setStatus(javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			"index.jsp", false, 1024, false);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>Title</title>\r\n");
      out.write("    ");
      out.print(new Date() );
      out.write("\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("    è¿æ¯ä¸ä¸ªæµè¯çjspé¡µé¢\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
```

## 8.4 jsp 中的常用脚本

### 8.4.1 第一种，声明脚本

* 格式

```
<%!
java 代码
%>
```

* 作用
  * 可以定义全局变量
  * .定义 static 静态代码块
  * 定义方法
  * 定义内部类
  * 写在类的内部写的代码，都可以通过声明脚本来实现
* 声明脚本不能将整体代码分开写，比如大括号里面的不能分成两个标签写。
* 声明脚本生成的代码为类的属性或方法

```jsp
<%@ page import="java.util.HashMap" %>
<%@ page import="java.util.Map" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="ISO-8859-1" %>

<html>
<head>
    <title>Title</title>
    <%--=============================声明脚本=======================--%>
    <%--1、声明类属性--%>
    <%!
        private Integer id;
        private String name;
        private static Map<String,Object> map;
    %>
    <%--2、声明static静态代码块--%>
    <%!
        static {
            map = new HashMap<String,Object>();
            map.put("key1", "value1");
            map.put("key2", "value2");
            map.put("key3", "value3");
        }
    %>
    <%--3、声明类方法--%>
    <%!
        public int abc(){
            return 12;
        }
    %>
    <%--4、声明内部类--%>
    <%!
        public static class A {
            private Integer id = 12;
            private String abc = "abc";
        }
    %>



    <%=new Date() %>
    <% int i = 1/0 ;%>
</head>
<body>
    这是一个测试的jsp页面
</body>
</html>
```

生成的java类

```java
public final class TestJspScript_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {


        private Integer id;
        private String name;
        private static Map<String,Object> map;
    

        static {
            map = new HashMap<String,Object>();
            map.put("key1", "value1");
            map.put("key2", "value2");
            map.put("key3", "value3");
        }
    

        public int abc(){
            return 12;
        }
    

        public static class A {
            private Integer id = 12;
            private String abc = "abc";
        }
        ....
}
```



### 8.4.2 第二种，表达式脚本

* 格式

```
<%=表达式 %>
```

- 表达式脚本 用于向页面输出内容。
- 表达式脚本 翻译到 Servlet 程序的 service 方法中 以 out.print() 打印输出
- out 是 jsp 的一个内置对象，用于生成 html 的源代码
- 注意：表达式不要以分号结尾，否则会报错

* 表达式脚本可以输出任意类型。比如：
  * 1.输出整型
  * 2.输出浮点型
  * 3.输出字符串
  * 4.输出对象

```jsp
<%@ page import="java.util.HashMap" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.Date" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="ISO-8859-1" %>

<html>
<head>
    <title>Title</title>
<%--=============================表达式脚本=======================--%>
    <%=new Date() %>

</head>
<body>
    这是一个测试的jsp页面
</body>
</html>
```

### 8.4.3 第三种，代码脚本

* 格式

```
<% java 代码 %>
```

- 代码脚本里可以书写任意的 java 语句。
- 代码脚本的内容都会被翻译到 service 方法中。
- 所以 service 方法中可以写的 java 代码，都可以书写到代码脚本中
- 代码脚本可以分开写，搭配表达式脚本可以输出到页面
- 实现原理为在生成的jsp的java类中的service 方法中，加入了代码脚本，按顺序解析执行的，所以拆开也没有影响。

```
<%@ page import="java.util.HashMap" %>
<%@ page import="java.util.Map" %>
<%@ page import="java.util.Date" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="ISO-8859-1" %>

<html>
<head>
    <title>Title</title>
    <%--=============================代码脚本=======================--%>
    <%--2.代码脚本----for 循环语句--%>
    <table>
        <%
            for (int j = 0; j < 10; j++) {
        %>
        <tr>
            <td>第 <%=j + 1%>行</td>
        </tr>
        <%
            }
        %>
    </table>
    <%--3.翻译后java文件中_jspService方法内的代码都可以写--%>
    <%
        String username = request.getParameter("username");
        System.out.println("用户名的请求参数值是：" + username);
    %>
</head>
<body>
    这是一个测试的jsp页面
</body>
</html>

```

生成的java类

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.0.26
 * Generated at: 2023-09-15 16:02:00 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Date;

public final class TestJspScript_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {
  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = new java.util.HashSet<>();
    _jspx_imports_classes.add("java.util.Date");
    _jspx_imports_classes.add("java.util.Map");
    _jspx_imports_classes.add("java.util.HashMap");
  }

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {

final java.lang.String _jspx_method = request.getMethod();
if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET POST or HEAD");
return;
}

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("\r\n");
      out.write("\r\n");
      out.write("\r\n");
      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>Title</title>\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("\r\n");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.print(new Date() );
      out.write("\r\n");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    <table>\r\n");
      out.write("        ");

            for (int j = 0; j < 10; j++) {
        
      out.write("\r\n");
      out.write("        <tr>\r\n");
      out.write("            <td>第 ");
      out.print(j + 1);
      out.write("行</td>\r\n");
      out.write("        </tr>\r\n");
      out.write("        ");

            }
        
      out.write("\r\n");
      out.write("    </table>\r\n");
      out.write("    ");
      out.write("\r\n");
      out.write("    ");

        String username = request.getParameter("username");
        System.out.println("用户名的请求参数值是：" + username);
    
      out.write("\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("    这是一个测试的jsp页面\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```

## 8.5 jsp 中的注释

```
// 单行 java 注释
/* 多行 java 代码注释
*/
单行注释和多行注释能在翻译后的 java 源代码中看见。
在<% %>标签中使用java注释
```

```
<%-- jsp 注释 --%>
jsp 注释在翻译的时候会直接被忽略掉，如果包含了java注释和html注释都会被忽略掉。
```

```
<!-- html 注释 -->
html 的注释会被翻译到 java 代码中输出到 html 页面中查看
```



## 8.6 九大内置对象

* 内置对象包括
  * request 对象 请求对象，可以获取请求信息
  * response 对象 响应对象。可以设置响应信息
  * pageContext 对象 当前页面上下文对象。可以在当前上下文保存属性信息
  * session 对象 会话对象。可以获取会话信息。
  * exception 对象 异常对象只有在 jsp 页面的 page 指令中设置 isErrorPage=*"true"* 的时候才会存在
  * application 对象 ServletContext 对象实例，可以获取整个工程的一些信息。
  * config 对象 ServletConfig 对象实例，可以获取 Servlet 的配置信息
  * out 对象 输出流。
  * page 对象 表示当前 Servlet 对象实例（无用，用它不如使用 this )
* 内置对象时_jspService方法里面的对象实例名，在jsp页面代码脚本<%%>中可以直接使用。

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/8.0.26
 * Generated at: 2023-09-16 03:40:59 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class error500_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private javax.el.ExpressionFactory _el_expressionfactory;
  private org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public void _jspInit() {
    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
    _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
        throws java.io.IOException, javax.servlet.ServletException {
	//内置对象1 pageContext
    final javax.servlet.jsp.PageContext pageContext;
    //内置对象2 session
    javax.servlet.http.HttpSession session = null;
    //内置对象3 exception
    java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);
    if (exception != null) {
      response.setStatus(javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    }
    //内置对象4 application
    final javax.servlet.ServletContext application;
    //内置对象5 config
    final javax.servlet.ServletConfig config;
    //内置对象6 out
    javax.servlet.jsp.JspWriter out = null;
    //内置对象7 page
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;

	//内置对象8 方法的传参request 
    //内置对象9 方法的传参response
    try {
      response.setContentType("text/html;charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("    <title>Title</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("    很抱歉，您访问的页面服务器出现错误，程序猿小哥正在努力为您抢修！！！\r\n");
      out.write("</body>\r\n");
      out.write("</html>\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}
```

## 8.7 jsp 四大域对象

* 四大域对象经常用来保存数据信息
  * pageContext 可以保存数据在同一个 jsp 页面中使用
  * request 可以保存数据在同一个 request 对象中使用。经常用于在转发的时候传递数据
  * session 可以保存在一个会话中使用
  * application(ServletContext) 就是 ServletContext 对象

- 四个作用域的测试代码：
  - 新建两个 jsp 页面。分别取名叫：scope.jsp，scope2.jsp
- 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序
  - pageContext ====>>> request ====>>> session ====>>> application

scope.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Administrator
  Date: 2020/2/23
  Time: 21:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>scope.jsp页面</h1>
    <%
        // 往四个域中都分别保存了数据
        pageContext.setAttribute("key", "pageContext");
        request.setAttribute("key", "request");
        session.setAttribute("key", "session");
        application.setAttribute("key", "application");
    %>
    pageContext域是否有值：<%=pageContext.getAttribute("key")%> <br>
    request域是否有值：<%=request.getAttribute("key")%> <br>
    session域是否有值：<%=session.getAttribute("key")%> <br>
    application域是否有值：<%=application.getAttribute("key")%> <br>
    <%
//        request.getRequestDispatcher("/scope2.jsp").forward(request,response);
    %>
    <%--
        <jsp:forward page=""></jsp:forward> 是请求转发标签，它的功能就是请求转发
            page 属性设置请求转发的路径
    --%>
    <jsp:forward page="/scope2.jsp"></jsp:forward>
</body>
</html>

```

scope2.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: Administrator
  Date: 2020/2/23
  Time: 21:23
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>scope2.jsp页面</h1>
    pageContext域是否有值：<%=pageContext.getAttribute("key")%> <br>
    request域是否有值：<%=request.getAttribute("key")%> <br>
    session域是否有值：<%=session.getAttribute("key")%> <br>
    application域是否有值：<%=application.getAttribute("key")%> <br>
</body>
</html>
```

* 测试结论：

  1、直接访问scope2.jsp，所有值为null

  2、直接访问scope.jsp，scope.jsp请求转发到scope2.jsp，这时只有pageContext域是null。证明pageContext只在当前页面有效。再直接访问scope2.jsp，pageContext和request为null，证明 request只一次请求有效。

  3、关闭浏览器后再访问scope2.jsp，只有application有值，证明session是针对浏览器有效，关闭浏览器再打开失效。

  4、重启应用后再访问scope2.jsp，所有值为null，证明application是整个应用有效，重启后失效。

## 8.8 jsp 中 out 输出流 和 response.getwriter()输出流

* jsp 中 out 和 response 的 writer 的区别演示

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
  <%
    // out 输出
    out.write("这是 out 的第一次输出<br/>");
  // out flush 之后。会把输出的内容写入 writer 的缓冲区中
    out.flush();
  // 最后一次的输出，由于没有手动 flush，会在整个页面输出到客户端的时候，自动写入到 writer
//    缓冲区
    out.write("这是 out 的第二次输出<br/>");
  // writer 的输出
    response.getWriter().write("这是 writer 的第一次输出<br/>");
    response.getWriter().write("这是 writer 的第二次输出<br/>");
  %>
</body>
```

输出结果，不是按照代码顺序执行的：

```
这是 out 的第一次输出
这是 writer 的第一次输出
这是 writer 的第二次输出
这是 out 的第二次输出
```

* 内置对象out有单独的缓冲区，out对象是JspWriterImpl，JspWriterImpl对象封装了response对象，数据刷新缓存区时，刷新的是JspWriterImpl的缓冲区，把数据追加到response的Writer中。
* response.getWriter()是直接将数据放入到response的Writer中。
* 所以就算代码是前后顺序，也需要等待out对象将数据刷入到response才能展示到页面，所以顺序不是代码顺序。

## 8.9 jsp 的常用标签

### 8.9.1 jsp 静态包含（常用）

* 格式

```jsp
<%@ include file=""%>

file 属性指定你要包含的 jsp 页面的路径
地址中第一个斜杠 / 表示为 http://ip:port/工程路径/ 映射到代码的 web 目录
```

* *静态包含的特点：*

  1、静态包含不会翻译被包含的jsp 页面。

  2、静态包含其实是把被包含的jsp页面的代码拷贝到包含的位置执行输出。

```jsp
如：<%@ include file="/include/footer.jsp"%>
```

### 8.9.2 jsp 动态包含

* 格式

```jsp
<jsp:include page=""></jsp:include>
```

* page 属性是指定你要包含的 jsp页面的路径
* 动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置

* *动态包含的特点：*

  1、动态包含会把包含的 jsp 页面也翻译成为 java 代码

  2、动态包含底层代码使用如下代码去调用被包含的 jsp 页面执行输出JspRuntimeLibrary.include(request, response, "/include/footer.jsp", out, false);

  3、动态包含，还可以传递参数

```jsp
如：
<jsp:include page="/include/footer.jsp">
    <jsp:param name="username" value="bbj"/>
    <jsp:param name="password" value="root"/>
</jsp:include>
```



### 8.9.3 jsp 标签-转发

* 格式

```jsp
<jsp:forward page=""></jsp:forward>

是请求转发标签，它的功能就是请求转发page 属性设置请求转发的路径
```

```jsp
如
<jsp:forward page="/scope2.jsp"></jsp:forward>
与
<% request.getRequestDispatcher("/scope2.jsp").forward(request,response); %>
是一样的的效果
```

