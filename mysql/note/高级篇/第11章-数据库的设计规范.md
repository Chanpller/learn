# 第11章-数据库的设计规范

## 11.1 为什么需要数据库设计

* 保证数据正确性，避免更新、插入、删除异常。
* 降低数据冗余度，避免数据重复，减少存储空间浪费
* 方便的维护数据库
* 提升程序性能
* 保证有效信息

## 11.2 范 式

### 11.2.1 范式简介

* 在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。
* 英文名Normal Form(解释：范式、正规形式、标准形式)，简称NF，英国人E.F.Codd上世纪70年代提出。

### 11.2.2 范式都包括哪些

* 第一范式（1NF）
* 第二范式（2NF）
* 第三范式（3NF）
* 巴斯-科德范式（BCNF）
* 第四范式(4NF）
* 第五范式（5NF，又称完美范式）

### 11.2.3 键和相关属性的概念

```
这里有两个表：
球员表(player) ：球员编号 | 姓名 | 身份证号 | 年龄 | 球队编号
球队表(team) ：球队编号 | 主教练 | 球队所在地
```

* 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如（球员编号）（球员编号，姓名）（身份证号，年龄）等。
* 候选键：不含有多余属性的超键称为候选键。就是最小的超键，对于球员表来说，候选键就是（球员编号）或者（身份证号）。
* 主键：用户选作元组标识的一个候选键程序主键，一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。我们自己选定，也就是从候选键中选择一个，比如（球员编号）。
* 外键：在一个表中存在的另一个表的主键称此表的外键。球员表中的球队编号。
* 主属性、非主属性：在球员表中，主属性是（球员编号）（身份证号），其他的属性（姓名）
  （年龄）（球队编号）都是非主属性。
* 超键包含着候选键，候选键中包含着主键。主键一定是惟一的。

```
自己理解
超键：超越键，可以是可以作为主键的列+属性列。
候选键：可以作为唯一属性的键，也就是可以当主键的列。
主键：从候选键中选一个列作为主键。
```

### 11.2.4 第一范式（1st NF）

* 保证每个字段的值必须具有原子性，即字段数据不能拆分。
* 解决数据原子性问题。
* 确保每列保持原子性

### 11.2.5 第二范式（1nd NF）

* 在第一范式的基础上，满足数据表的每条数据都是可唯一标识的（即每条数据都能有主键），而且非主键字段必须完全依赖主键，不能只依赖主键的一部分。
* 1NF 告诉我们字段属性需要是原子性的，而 2NF 告诉我们一张表就是一个独立的对象，一张表只表达一个意思。
* 解决数据数据冗余，更新、插入、删除数据时数据太多、关联关系异常的问题。
* 确保每列与主键完全依赖，不能出现组合索引下部分列依赖。

```
举例1
成绩表（学号，课程号，成绩）关系中，（学号，课程号）可以决定成绩，但是学号不能决定成绩，课程号也不能决定成绩，所以“（学号，课程号）→成绩”就是完全依赖关系。所以需要使用学号，课程号来设计成主键。

举例2
如果球员表这样设计，以球员编号, 比赛编号为主键
(球员编号, 比赛编号) → (姓名, 年龄, 比赛时间, 比赛场地，得分)
比赛时间与球员编号没有关系，就不满足第二范式。这样就是非主属性不是完全依赖候选键。
带来的问题：
数据冗余
插入异常
删除异常
更新异常
```

### 11.2.6 第三范式（3rd NF）

* 在第二范式的基础上，所有非主键字段不能依赖其他非主键字段。
* 即非主键属性之间不能有依赖关系，是相互独立的。
* 解决数据冗余问题
* 确保每列与主键列直接相关，每列之间没有间接关联。

```
举例
员工表设计为：员工编号、姓名、部门编号、部门名称
满足第二范式，姓名、部门编号、部门名称都依赖于员工编号，但是部门名称依赖部门编号，这样设计会导致数据容易，多存储了一个部门名称。部门名称应该放在部门表，这样设计就满足第三范式
```

### 11.2.7 范式优缺点

* 优点：消除数据库中的冗余数据。第三范式在性能、扩展性和数据完整性达到了最好的平衡。
* 缺点：降低查询效率。范式等级越高，设计的表越多，冗余度越低，查询时可能需要关联多张表，效率低，还可能导致一些索引策略无效。

## 11.3 反范式化

- 为满足某种商业目标 , 数据库性能比规范化数据库更重要
- 在数据规范化的同时 , 要综合考虑数据库的性能
- 通过在给定的表中添加额外的字段，以大量减少需要从中搜索信息所需的时间
- 通过在给定的表中插入计算列，以方便查询

反范式的新问题

* 存储空间变大
* 一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则数据不一致
* 若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常消耗系统资源
* 在数据量小的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加复杂

反范式的适用场景

* 当冗余信息有价值或者能大幅度提高查询效率的时候，我们才会采取反范式的优化。
* 每次发生的订单收货信息都属于历史快照，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。
* 反范式优化也常用在数据仓库的设计中，因为数据仓库通常存储历史数据，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。

## 11.4 BCNF(巴斯范式)

* 3NF 的基础上消除了主属性对候选键的部分依赖或者传递依赖关系

* BCNF是两个人提出来的。

```
举例
比如联合主键：创库、管理员、物品名作为联合主键，数量作为主属性。
创库、管理员、物品名确认管理员仓库的商品数量。假如新增了一个仓库，还没有管理员，那是无法创建的。
因为联合主键不能有空的。这个就不满足巴斯范式。这时候需要还分为。
创库表（创库、管理员） 库存表（创库、物品名、数量）
```

## 11.5 第四范式

* 多值依赖：属性之间的一对多关系。
* 函数依赖：实际上是单值依赖，不能表达为属性之间的一对多关系。
* 平凡的多值依赖：一组一对多关系。
* 非平凡的多值依赖：整个组有多组一对多关系，且有一部分是相同的属性集合，多部分是相互独立的属性集合。
* 第四范式在巴斯范式基础上，消除非平凡且非函数依赖的多值依赖。（即把同一表内的多对多关系删除）

```

举例
职工表(职工编号，职工孩子姓名，职工选修课程)。
一个职工编号，可以对应多个孩子姓名，一个职工编号可以对应多个职工选修课程。职工孩子姓名与职工选修课程是相互独立的。就存在两组一对多关系。这个就是非平凡的多只依赖

如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实。
```

## 11.6 第五范式、域键范式

* 除了第四范式外，我们还有更高级的第五范式（又称完美范式）和域键范式（DKNF）。
* 在满足第四范式（4NF）的基础上，消除不是由候选键所蕴含的连接依赖。如果关系模式R中的每一个连接依赖均由R的候选键所隐含，则称此关系模式符合第五范式。
* 函数依赖是多值依赖的一种特殊的情况，而多值依赖实际上是连接依赖的一种特殊情况。但连接依赖不像函数依赖和多值依赖可以由语义直接导出，而是在关系连接运算时才反映出来。存在连接依赖的关系模式仍可能遇到数据冗余及插入、修改、删除异常等问题。
* 第五范式处理的是无损连接问题，这个范式基本没有实际意义，因为无损连接很少出现，而且难以察觉。而域键范式试图定义一个终极范式，该范式考虑所有的依赖和约束类型，但是实用价值也是最小的，只存在理论研究中。

## 11.7 ER模型

* Entity-Relation 实例关系模型

### 11.7.1 ER模型中要素

* 分别是实体、属性和关系。

* 实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。在 ER 模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。
* 属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在 ER 模型中用椭圆形来表示。
* 关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在 ER 模型中用菱形来表示。

### 11.7.2 关系的类型

* 一对一
* 一对多
* 多对多

### 11.7.3 ER模型图转换成数据表

* 一个实体通常转换成一个数据表
* 一个多对多的关系，通常也转换成一个数据表
* 一个 1 对 1 ，或者 1 对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表
* 属性转换成表的字段

## 11.8 数据表的设计原则

* 数据表的个数越少越好
  * 表越少，关系越简单，越容易理解和操作
* 数据表中的字段个数越少越好
  * 字段越少，冗余数据越少，但是通常会在数据冗余和性能上选择平衡。
* 数据表中联合主键的字段个数越少越好
  * 主键越短，B+数叶子节点存储越多，树越扁平，查询快。
* 使用主键和外键越多越好
  * 外键指的外部表主键，使用索引越多越好。

## 10.9 数据库对象编写建议

### 10.9.1 关于库

* 【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头

* 【强制】库名中英文一律小写，不同单词采用下划线分割。须见名知意

* 【强制】库的名称格式：业务系统名称_子系统名

* 【强制】库名禁止使用关键字（如type,order等）

* 【强制】创建数据库时必须显式指定字符集，并且字符集只能是utf8或者utf8mb4。
  创建数据库SQL举例：CREATE DATABASE crm_fund **DEFAULT CHARACTER SET 'utf8'** ;

* 【建议】对于程序连接数据库账号，遵循权限最小原则

  使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号原则上不准有drop权限

* 【建议】临时库以tmp_ 为前缀，并以日期为后缀

* 【建议】备份库以 bak_ 为前缀，并以日期为后缀

### 10.9.2 关于表、列

* 【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以英文字母开头。

* 【强制】表名、列名一律小写，不同单词采用下划线分割。须见名知意。

* 【强制】表名要求有模块名强相关，同一模块的表名尽量使用统一前缀。比如：crm_fund_item

* 【强制】创建表时必须显式指定字符集为utf8或utf8mb4。

* 【强制】表名、列名禁止使用关键字（如type,order等）。

* 【强制】创建表时必须显式指定表存储引擎类型。如无特殊需求，一律为InnoDB。

* 【强制】建表必须有comment。

* 【强制】字段命名应尽可能使用表达实际含义的英文单词或缩写。如：公司 ID，不要使用corporation_id, 而用corp_id 即可。

* 【强制】布尔值类型的字段命名为is_描述。如member表上表示是否为enabled的会员的字段命名为 is_enabled。

* 【强制】禁止在数据库中存储图片、文件等大的二进制数据

  通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随
  机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息

* 【建议】建表时关于主键： 表必须有主键 (1)强制要求主键为id，类型为int或bigint，且为
  auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议
  设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机
  插入，则会导致innodb内部页分裂和大量随机I/O，性能下降
* 建议】核心表（如用户表）必须有行数据的创建时间字段（create_time）和最后更新时间字段（update_time），便于查问题
* 【建议】表中所有字段尽量都是NOT NULL 属性，业务可以根据需要定义DEFAULT值。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问题
* 【建议】所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）
* 【建议】中间表（或临时表）用于保留中间结果集，名称以tmp_ 开头
* 【建议】备份表用于备份或抓取源表快照，名称以bak_ 开头。中间表和备份表定期清理
* 【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上

### 10.9.3 关于索引

* 【强制】InnoDB表必须主键为id int/bigint auto_increment，且主键值禁止被更新。
* 【强制】InnoDB和MyISAM存储引擎表，索引类型必须为BTREE 。
* 【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。
* 【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample 表 member_id 上的索引：idx_sample_mid。
* 【建议】单个表上的索引个数不能超过6个。
* 【建议】在建立索引时，多考虑建立联合索引，并把区分度最高的字段放在最前面。
* 【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。
* 【建议】建表或加索引时，保证表里互相不存在冗余索引。 比如：如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除。

### 10.9.4 SQL编写

* 【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。
* 【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。
* 【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。
* 【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很
  快，但会引起主从同步延迟。
* 【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以
  内。
* 【建议】线上环境，多表 JOIN 不要超过5个表。
* 【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDER BY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。
* 【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。
* 【建议】对单表的多次alter操作必须合并为一次，因为alter table会产生表锁，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。
* 【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。
* 【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。
* 【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id=XX;否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。

## 11.11 PowerDesigner的使用

PowerDesigner是一款开发人员常用的数据库建模工具，用户利用该软件可以方便地制作数据流程图、概念数据模型、物理数据模型，它几乎包括了数据库模型设计的全过程，是Sybase公司为企业建模和设计提供的一套完整的集成化企业级建模解决方案。

* “Create Model”的作用类似于普通的一个文件，该文件可以单独存放也可以归类存放。
* “Create Project”的作用类似于文件夹，负责把有关联关系的文件集中归类存放。
* 常用的模型有4种，分别是概念模型(CDM Conceptual Data Model) ， 物理模型（PDM,Physical Data Model） ， 面向对象的模型（OOM Objcet Oriented Model） 和业务模型（BPM Business Process Model） 
* Conceptual 可以转化为Physical 模型，Physical 模型可以转化为对应的数据库的sql。